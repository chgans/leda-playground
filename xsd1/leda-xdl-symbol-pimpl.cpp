// Not copyrighted - public domain.
//
// This sample parser implementation was generated by CodeSynthesis XSD,
// an XML Schema to C++ data binding compiler. You may use it in your
// programs without any restrictions.
//

#include "leda-xdl-symbol-pimpl.h"

#include <QDebug>

#define DBG qDebug() << __PRETTY_FUNCTION__

// Black pen, cosmetic (width = 0.0), solid aith round joins and round cap
static const QPen DEFAUL_PEN(QBrush(Qt::black), 0.0, Qt::SolidLine, Qt::RoundCap, Qt::RoundJoin);
static const QBrush DEFAULT_BRUSH(Qt::NoBrush);

namespace xdl
{
// Symbol_pimpl
//

void Symbol_pimpl::pre()
{
    m_name.clear();
    m_label.clear();
    m_drawing.clear();
}

void Symbol_pimpl::name(const ::std::string& name)
{
    m_name = QString::fromStdString(name);
}

void Symbol_pimpl::label(const ::std::string& label)
{
    m_label = QString::fromStdString(label);
}

void Symbol_pimpl::drawing(QList<QGraphicsItem*> drawing)
{
    m_drawing = drawing;
}

Symbol* Symbol_pimpl::post_Symbol()
{
    Symbol *sym = new Symbol();
    sym->caption = m_name;
    sym->description = m_label;
    sym->drawings = m_drawing;
    return sym;
}

// ItemList_pimpl
//

void ItemList_pimpl::pre()
{
    m_items.clear();
}

void ItemList_pimpl::ellipse(QGraphicsEllipseItem* ellipse)
{
    ellipse->setData(0, "ellipse");
    m_items.append(ellipse);
}

void ItemList_pimpl::line(QGraphicsLineItem* line)
{
    line->setData(0, "line");
    m_items.append(line);
}

void ItemList_pimpl::pin(QGraphicsEllipseItem *pin)
{
    pin->setData(0, "pin");
    m_items.append(pin);
}

void ItemList_pimpl::rectangle(QGraphicsRectItem* rectangle)
{
    rectangle->setData(0, "rectangle");
    m_items.append(rectangle);
}

void ItemList_pimpl::group(QGraphicsItemGroup* group)
{
    group->setData(0, "group");
    m_items.append(group);
}

void ItemList_pimpl::arc(QGraphicsPathItem *arc)
{
    arc->setData(0, "arc");
    m_items.append(arc);
}

void ItemList_pimpl::label(QGraphicsSimpleTextItem *label)
{    
    label->setData(0, "label");
    m_items.append(label);
}

QList<QGraphicsItem*> ItemList_pimpl::post_ItemList()
{
    return m_items;
}

// Item_pimpl
//

void Item_pimpl::pre()
{
    m_position = QPointF();
    m_zValue = 0.0;
    m_rotation = 0.0;
    m_opacity = 1.0;
    m_locked = false;
    m_transform = QTransform();
    m_visible = true;
}

void Item_pimpl::position(const QPointF& position)
{
    m_position = position;
}

void Item_pimpl::z_value(double z_value)
{
    m_zValue = z_value;
}

void Item_pimpl::rotation(const qreal& rotation)
{
    m_rotation = rotation;
}

void Item_pimpl::opacity(const qreal& opacity)
{
    m_opacity = opacity;
}

void Item_pimpl::locked(bool locked)
{
    m_locked = locked;
}

void Item_pimpl::mirrored(const QTransform& mirrored)
{
    m_transform = mirrored;
}

void Item_pimpl::visible(bool visible)
{
    m_visible = visible;
}

void Item_pimpl::post_Item()
{
    m_item->setPos(m_position);
    m_item->setZValue(m_zValue);
    m_item->setRotation(m_rotation);
    m_item->setOpacity(m_opacity);
    m_item->setEnabled(!m_locked);
    m_item->setTransform(m_transform);
    m_item->setVisible(m_visible);
}

// Shape_pimpl
//

void Shape_pimpl::pre()
{
    Item_pimpl::pre();
    m_pen = DEFAUL_PEN;
    m_brush = DEFAULT_BRUSH;
}

void Shape_pimpl::pen(const QPen& pen)
{
    m_pen = pen;
}

void Shape_pimpl::brush(const QBrush& brush)
{
    m_brush = brush;
}

void Shape_pimpl::post_Shape()
{
    m_item = m_shapeItem;
    post_Item();
    m_shapeItem->setBrush(m_brush);
    m_shapeItem->setPen(m_pen);
}

// Ellipse_pimpl
//

void Ellipse_pimpl::pre()
{
    Shape_pimpl::pre();
    m_center = QPointF();
    m_xRadius = 0.0;
    m_yRadius = 0.0;
    m_startAngle = 0.0;
    m_spanAngle = 360.0;
}

void Ellipse_pimpl::center(const QPointF& center)
{
    m_center = center;
}

void Ellipse_pimpl::x_radius(const qreal &x_radius)
{
    m_xRadius = x_radius;
}

void Ellipse_pimpl::y_radius(const qreal &y_radius)
{
    m_yRadius = y_radius;
}

void Ellipse_pimpl::start_angle(const qreal &start_angle)
{
    m_startAngle = start_angle;
}

void Ellipse_pimpl::span_angle(const qreal &span_angle)
{
    m_spanAngle = span_angle;
}

QGraphicsEllipseItem* Ellipse_pimpl::post_Ellipse()
{
    QGraphicsEllipseItem *ellipse = new QGraphicsEllipseItem();
    m_shapeItem = ellipse;
    post_Shape();
    ellipse->setStartAngle(m_startAngle*16);
    ellipse->setSpanAngle(m_spanAngle*16);
    ellipse->setRect(m_center.x() - m_xRadius,
                     m_center.y() - m_yRadius,
                     m_xRadius*2.0,
                     m_yRadius*2.0);
    return ellipse;
}

// Rectangle_pimpl
//

void Rectangle_pimpl::pre()
{
    Shape_pimpl::pre();
    m_topLeft = QPointF();
    m_bottomRight = QPointF();
}

void Rectangle_pimpl::top_left(const QPointF& top_left)
{
    m_topLeft = top_left;
}

void Rectangle_pimpl::bottom_right(const QPointF& bottom_right)
{
    m_bottomRight = bottom_right;
}

QGraphicsRectItem* Rectangle_pimpl::post_Rectangle()
{
    QGraphicsRectItem *rect  = new QGraphicsRectItem();
    m_shapeItem = rect;
    post_Shape();
    rect->setRect(QRectF(m_topLeft, m_bottomRight));
    return rect;
}

// Line_pimpl
//

void Line_pimpl::pre()
{
    Item_pimpl::pre();
    m_line = QLineF();
    m_pen = DEFAUL_PEN;
}

void Line_pimpl::points(const QList<QPointF>& points)
{
    // FIXME: the XSD doesn't enforce nb of points
    // Anyway, we want a poly line item, ....
    m_line.setP1(points.at(0));
    m_line.setP2(points.at(1));
}

void Line_pimpl::pen(const QPen& pen)
{
    m_pen = pen;
}

QGraphicsLineItem* Line_pimpl::post_Line()
{
    QGraphicsLineItem *line = new QGraphicsLineItem();
    m_item = line;
    post_Item();
    line->setLine(m_line);
    line->setPen(m_pen);
    return line;
}

// Pin_pimpl
//

void Pin_pimpl::pre()
{
    Item_pimpl::pre();
}

// FIXME
void Pin_pimpl::designator(const ::std::string& designator)
{
    m_designator = QString::fromStdString(designator);
}

QGraphicsEllipseItem *Pin_pimpl::post_Pin()
{
    QGraphicsEllipseItem *ellipse = new QGraphicsEllipseItem();
    m_item = ellipse;
    post_Item();
    ellipse->setPen(QPen(QBrush(Qt::red), 0.0));
    ellipse->setRect(-3.5, -3.5, 7, 7);
    return ellipse;
}

// ItemGroup_pimpl
//

void ItemGroup_pimpl::pre()
{
    m_children.clear();
}

void ItemGroup_pimpl::children(QList<QGraphicsItem*> children)
{
    m_children = children;
}

QGraphicsItemGroup* ItemGroup_pimpl::post_ItemGroup()
{
    QGraphicsItemGroup *group = new QGraphicsItemGroup();
    m_item = group;
    post_Item();
    foreach (QGraphicsItem *child, m_children)
        group->addToGroup(child);
    return group;
}

// Arc_pimpl
//

void Arc_pimpl::pre()
{
    Shape_pimpl::pre();
    m_center = QPointF();
    m_xRadius = 0.0;
    m_yRadius = 0.0;
    m_startAngle = 0.0;
    m_spanAngle = 360.0;
}

void Arc_pimpl::center(const QPointF& center)
{
    m_center = center;
}

void Arc_pimpl::x_radius(const qreal &x_radius)
{
    m_xRadius = x_radius;
}

void Arc_pimpl::y_radius(const qreal &y_radius)
{
    m_yRadius = y_radius;
}

void Arc_pimpl::start_angle(const qreal &start_angle)
{
    m_startAngle = start_angle;
}

void Arc_pimpl::span_angle(const qreal &span_angle)
{
    m_spanAngle = span_angle;
}

QGraphicsPathItem* Arc_pimpl::post_Arc()
{
    QGraphicsPathItem *item = new QGraphicsPathItem();
    m_shapeItem = item;
    post_Shape();
    QPainterPath path;
    QRectF rect(m_center.x() - m_xRadius,
                m_center.y() - m_yRadius,
                m_xRadius*2.0,
                m_yRadius*2.0);
    path.arcMoveTo(rect, m_startAngle);
    path.arcTo(rect, m_startAngle, m_spanAngle);
    item->setPath(path);
    return item;
}

// Label_pimpl
//

void Label_pimpl::pre()
{
    Shape_pimpl::pre();
    m_font = QFont();
    m_text.clear();
    // Override default shape pen/brush
    m_pen = QPen(Qt::NoPen);
    m_brush = QBrush(Qt::black, Qt::SolidPattern);
}

void Label_pimpl::text(const std::string &text)
{
    m_text = QString::fromStdString(text);
}

void Label_pimpl::font(const QFont &font)
{
    m_font = font;
}

QGraphicsSimpleTextItem *Label_pimpl::post_Label()
{
    QGraphicsSimpleTextItem *item = new QGraphicsSimpleTextItem();
    m_shapeItem = item;
    post_Shape();
    item->setFont(m_font);
    item->setText(m_text);
    return item;
}

// Point_pimpl
//

void Point_pimpl::pre()
{
    m_x = 0.0;
    m_y = 0.0;
}

void Point_pimpl::x(double x)
{
    m_x = x;
}

void Point_pimpl::y(double y)
{
    m_y = y;
}

QPointF Point_pimpl::post_Point()
{
    return QPointF(m_x, m_y);
}

// PointList_pimpl
//

void PointList_pimpl::pre()
{
    m_points.clear();
}

void PointList_pimpl::point(const QPointF& point)
{
    m_points.append(point);
}

QList<QPointF> PointList_pimpl::post_PointList()
{
    return m_points;
}

// Pen_pimpl
//

void Pen_pimpl::pre()
{
    m_pen = DEFAUL_PEN;
}

void Pen_pimpl::width(const qreal &width)
{
    m_pen.setWidthF(width);
}

void Pen_pimpl::color(const QColor& color)
{
    m_pen.setColor(color);
}

void Pen_pimpl::style(const Qt::PenStyle& style)
{
    m_pen.setStyle(style);
}

void Pen_pimpl::cap_style(const Qt::PenCapStyle& cap_style)
{
    m_pen.setCapStyle(cap_style);
}

void Pen_pimpl::join_style(const Qt::PenJoinStyle& join_style)
{
    m_pen.setJoinStyle(join_style);
}

QPen Pen_pimpl::post_Pen()
{
    return m_pen;
}

// Brush_pimpl
//

void Brush_pimpl::pre()
{
    m_brush = DEFAULT_BRUSH;
}

void Brush_pimpl::color(const QColor& color)
{
    m_brush.setColor(color);
}

void Brush_pimpl::style(const Qt::BrushStyle &style)
{
    m_brush.setStyle(style);
}

QBrush Brush_pimpl::post_Brush()
{
    return m_brush;
}

// PenStyle_pimpl
//

void PenStyle_pimpl::pre()
{
}

Qt::PenStyle PenStyle_pimpl::post_PenStyle()
{
    const ::std::string& v(post_string());
    if (v == "NoPen")
        return Qt::NoPen;
    if (v == "SolidLine")
        return Qt::SolidLine;
    if (v == "DashLine")
        return Qt::DashLine;
    if (v == "DashDotLine")
        return Qt::DashDotLine;
    if (v == "DashDotdotLine")
        return Qt::DashDotDotLine;
    return Qt::SolidLine;
}

// PenCapStyle_pimpl
//

void PenCapStyle_pimpl::pre()
{
}

Qt::PenCapStyle PenCapStyle_pimpl::post_PenCapStyle()
{
    const ::std::string& v(post_string());
    if (v == "Flat")
        return Qt::FlatCap;
    if (v == "Square")
        return Qt::SquareCap;
    if (v == "Round")
        return Qt::RoundCap;
    return Qt::SquareCap;
}

// PenJoinStyle_pimpl
//

void PenJoinStyle_pimpl::pre()
{
}

Qt::PenJoinStyle PenJoinStyle_pimpl::post_PenJoinStyle()
{
    const ::std::string& v(post_string());
    if (v == "Miter")
        return Qt::MiterJoin;
    if (v == "Bevel")
        return Qt::BevelJoin;
    if (v == "Round")
        return Qt::RoundJoin;
    return Qt::RoundJoin;
}

// BrushStyle_pimpl
//

void BrushStyle_pimpl::pre()
{
}

Qt::BrushStyle BrushStyle_pimpl::post_BrushStyle()
{
    const ::std::string& v(post_string());
    if (v == "NoBrush")
        return Qt::NoBrush;
    if (v == "Solid")
        return Qt::SolidPattern;
    if (v == "Horizontal")
        return Qt::HorPattern;
    if (v == "Vertical")
        return Qt::VerPattern;
    if (v == "Cross")
        return Qt::CrossPattern;
    if (v == "BDiagonal")
        return Qt::BDiagPattern;
    if (v == "FDiagonal")
        return Qt::FDiagPattern;
    if (v == "CrossDiagonal")
        return Qt::DiagCrossPattern;
    return Qt::SolidPattern;
}

// Color_pimpl
//

void Color_pimpl::pre()
{
}

QColor Color_pimpl::post_Color()
{
    return QColor(QString::fromStdString(post_string()));
}

// Side_pimpl
//

void Side_pimpl::pre()
{
}

// FIXME
void Side_pimpl::post_Side()
{
    const ::std::string& v(post_string());
    DBG << QString::fromStdString(v);
}

// Angle_pimpl
//

void Angle_pimpl::pre()
{
}

qreal Angle_pimpl::post_Angle()
{
    return post_double();
}

// Opacity_pimpl
//

void Opacity_pimpl::pre()
{
}

qreal Opacity_pimpl::post_Opacity()
{
    return post_double();
}

// Mirroring_pimpl
//

void Mirroring_pimpl::pre()
{
    m_xScale = 1.0;
    m_yScale = 1.0;
}

void Mirroring_pimpl::x(bool x)
{
    if (x)
        m_xScale = -1.0;
}

void Mirroring_pimpl::y(bool y)
{
    if (y)
        m_yScale = -1.0;
}

QTransform Mirroring_pimpl::post_Mirroring()
{
    return QTransform::fromScale(m_xScale, m_yScale);
}

// NonNegativeDouble_pimpl
//

void NonNegativeDouble_pimpl::pre()
{
}

qreal NonNegativeDouble_pimpl::post_NonNegativeDouble()
{
    return post_double();
}

void Font_pimpl::pre()
{
}

void Font_pimpl::family(const std::string &family)
{
    m_font.setFamily(QString::fromStdString(family));
}

void Font_pimpl::size(unsigned long long size)
{
    m_font.setPointSize(size);
}

void Font_pimpl::bold(bool bold)
{
    m_font.setBold(bold);
}

void Font_pimpl::italic(bool italic)
{
    m_font.setItalic(italic);
}

void Font_pimpl::underline(bool underline)
{
    m_font.setUnderline(underline);
}

void Font_pimpl::strikeout(bool strikeOut)
{
        m_font.setStrikeOut(strikeOut);
}

QFont Font_pimpl::post_Font()
{
    return m_font;
}

}

